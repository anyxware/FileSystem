#pragma once

#include <ctime>
#include <string>
#include <fstream>
#include <vector>
#include "Map.h"
#include "FileSystem.h"
#include "BaseStructs.h"
#include "DiskIO.h"

class FileSystem;
/**
 * @brief структура для хранения метаинформации файла
   распологается перед файлом
   адресс файла фактически является адресом его INode 
   сразу за INode располагается контент файла
 * 
 */

struct INode
{
	/**
	 * @brief время создания файла
	 * 
	 */
	time_t createTime;
	/**
	 * @brief время последней модификации файла
	 * 
	 */
	time_t modifyTime;
	/**
	 * @brief идентификатор пользователя - владельца файла
	 	идентификатор пользователя, который создал этот файл
	 * 
	 */
	uid UID;
	/**
	 * @brief идентификатор группы к которой принадлежит пользователь
	 	идентификатор основной группы, к которой принадлежит пользователь
	 * 
	 */
	gid GID;
	/**
	 * @brief модификаторы пользователя
	 	первый бит отвичает за тип файла - директория или файл, если true то директория, если false то файл
		 остальные биты отвечает за позволения(permissions)
		 биты r отвечают за возможность чтения файла, биты w за возможность записи в файл, биты x за возможность исполнения файла
		 первые три бита отвечают за позволения пользователю, вторые три бита за позволения группе пользователя, последние три биты за позволения остальным пользователям
	 * 
	 */
	bool mode[10]; // drwxrwxrwx mode[0] = true if dir
	/**
	 * @brief размер файла - размер контента записанного в файл, не включая описатель
	 * 
	 */
	size_t size; // file size
	/**
	 * @brief адресс дескриптора файла
	 * 
	 */
	size_t address;
	/**
	 * @brief внешние адреса
	 	если файл занимает размер больше одного блока, то необходимо использовать адреса внешних блоков которые занимает файл
		 первые 6 адрессов - это прямые  адреса, т е адресса блоков в котором находится контент файла
		 последние два адреса - это косвенные адреса, т е адреса блоков, которые содержат не контент файла, а прямые указатели на блоки памяти, в которых содержится контент файла
	 * 
	 */
	size_t externAddresses[8]; // 6 direct and 2 indirect
	/**
	 * @brief указатель на дескриптор родительской директории
	 	в случае root этот указаетль равен 0
	 * 
	 */
	size_t parentAddress; // parent directory descriptor adress in filesystem
	size_t hash;
	/**
	 * @brief имя файла
	 * 
	 */
	std::string name;

	/**
	 * @brief метод для считывания INode с диска
	 	можно представить в качетсве простого считывания структуры из файлового потока с некоторыми особенностями(такими как использование паддингов)
	 	в случае ошибки будут выставлены соответствующие флаги потока
	 *
	 * @param disk диском является файловый двоичный поток работающий на ввод и вывод, эмулирующий работу настоящего диска
	 * @return size_t размер INode, считанной с диска - включает в себя размер всех элементов структуры а также padding
	 */
	size_t read(std::fstream& disk);
	/**
	 * @brief метод для записи INode на диска
	 	можно представить в качетсве простого записывания структуры в файловый поток с некоторыми особенностями(такими как использование паддингов)
	 	в случае ошибки будут выставлены соответствующие флаги потока
	 *
	 * @param disk диском является файловый двоичный поток работающий на ввод и вывод, эмулирующий работу настоящего диска
	 * @return size_t размер INode, записанной на диска - включает в себя размер всех элементов структуры а также padding
	 */
	size_t write(std::fstream& disk);
};

class FileSystem;

/**
 * @brief базовый класс для любого, хранимого на диске
	является простейшим классом, который предназначен для хранения какого-либо контента(текст, указатели на файлы)
	обечпечивает взаимодействие с файловой системой для наследников
	является некоторой прослойкой между такими классами как например файл и непосредственно файловой системой 
 * 
 */

class Entry
{
private:
	/**
	 * @brief хранится дескриптор записи для того чтобы она могла себя самоидентифицровать, т е определять свой адресс на диске, размер итд
	 * 
	 */
	INode inode;
	/**
	 * @brief размер INode 
	 * 
	 */
	size_t inodeSize; // content % BLOCK_SZ is equal to inode size
	/**
	 * @brief ссылка на файловую систему к которой принадлежит данная запись, необходимо для того чтобы обеспечить некоторый функционал объекта хранящегося на диске
	 	например добавление файла в директорию, чтение-запись файла
	 * 
	 */
	FileSystem& fs;
protected:
	/**
	 * @brief размер блока - две разные записи не могут одновременно находиться в одном и том же блоке
	 	каждый блок может хранить кусок записи, принадлежащий только одной записи
	 * 
	 */
	size_t BLOCK_SZ = 1024;

	// get-set
	/**
	 * @brief возвращает максимальный возможный размер файл
	 	максимальный размер ограничен количеством хранимых указателей и равен
		( 6 * BLOCK_SIZE                 ) + 2 * (BLOCK_SIZE / sizeof(size_t)                    ) * BLOCK_SIZE
		| суммарный размер прямых блоков |       | количество указателей, помещаюхся в один блок |
	 										| суммарный размер косвенных блоков                                 |	
	 * 
	 * @return size_t непосредственно посчитанный максимально допустимый размер файла
	 */
	uid getCurrentUID();
	uid getOwnUID();
	size_t getMaxSize();
	/**
	 * @brief возвращает текущий размер файла
	 * 
	 * @return size_t размер файла
	 */
	size_t getSize() { return inode.size; }
	/**
	 * @brief изменяет реальный размер файла
	 * 
	 * @param newSize новый установленный размер
	 */
	void setSize(size_t newSize) { inode.size = newSize; }
	/**
	 * @brief увеличивает размер файла на переданную величину
	 * 
	 * @param size размер на который нужно увеличить размер, является положительной величиной
	 */
	void incrSize(size_t size) { inode.size += size; }
	/**
	 * @brief уменьшает размер файла на переданную величину
	 * 
	 * @param size размер на который нужно уменьшить размер, является положительной величиной
	 */
	void decrSize(size_t size) { inode.size -= size; }
	/**
	 * @brief возвращает адресс записи(точнее адрес десриптора записи, который находится перед контентом записи)
	 * 
	 * @return size_t описанный выше адрес
	 */
	size_t getAddress() { return inode.address; }
	/**
	 * @brief возвращает размер дескриптора файла
	 * 
	 * @return size_t 
	 */
	size_t getInodeSize() { return inodeSize; }
	/**
	 * @brief обновляет время модификации
	 	этот метод вызывается при модификации файла и выставляет время последней модификации файла на текущее
	 * 
	 */
	void modifyTime() { inode.modifyTime = time(nullptr); }

	/**
	 * @brief этот метод необходим при загрузке записи в оперативную память с диска
	 	поскольку при загрузке в оперативную память блоки памяти становятся свободными они отдаются в карту свободных блоков
		 этот метод берет адрес блока из которого происходит считывание в опреативную память и помечает блок как свободный
	 * 
	 * @param curSize размер части файла, которая уже считана и записана в опреативную память
	 * @return size_t возвращается адрес блока, который теперь помечен как свободный
	 */
	size_t freeAddress(size_t curSize); // get external address and put it to free map
	/**
	 * @brief этот метод необходим при загрузке записи в из оперативной памяти на диск
	 	поскольку при загрузке на диск необходимо занимать блоки памяти, в которые записывается файл, то находятся свободне блоки и отдаются под использование файлом
		 этот метод берет свободный блок на диске в который происходит запись файла и помечает блок как занятый
	 * 
	 * @param curSize размер части файла, которая уже записана на диска
	 * @return size_t возвращается адрес блока, который теперь занят записью
	 */
	size_t takeAddress(size_t curSize); // put address to external adresses from free map

	/**
	 * @brief этот метод необходим для получения адреса блока по позиции
	 	поскольку расположение блоков занимаемых файлом может быть не подряд, то необходимо получить адрес блока в котором находится принятая позиция
		при этом статус блока с занятого на свободный не меняется
	 * 
	 * @param position позиция по которой необходимо вычислить адрес блока
	 * @return size_t адрес блока, в котором находится данная позиция
	 */
	size_t getAddress(size_t position); // get external address
	//size_t putAddress(size_t curSize); // put address to external adresses

	// read-write
	/**
	 * @brief этот метод необходим для получения имени записи по указанному адресу записи 
	 	в случае невалидного адреса, при считывании количества символов, может считаться большое число и при аллокации вылетит исключение
	 * 
	 * @param fileAddress адрес записи, у которой необходимо получить имя
	 * @return std::string имя записи
	 */
	std::string readName(size_t fileAddress);
	/**
	 * @brief считывание некоторой информации из файловой системы в буфер
	 	метод выполняет только функцию считывания, никаких дополнительных проверок не производится
	 * 
	 * @param address адрес информации, в случае невалидного адреса считается та информации, которая находится по этому адресу
	 * @param buffer буфер, в который происходит считывание информации, в случае невалидного буфера(например nullptr) возникнет ошибка сегментация
	 * @param BUF_SZ размер буфера - эквивалентно размеру считываемой информации
	 */
	void read(size_t address, char* buffer, size_t BUF_SZ);
	/**
	 * @brief запись некоторой информации из буфера в файловую систему
	 	метод выполняет только функцию записи, никаких дополнительных проверок не производится
	 * 
	 * @param address адрес, по которому будет проведена запись, в случае неверного адреса, может произойти потеря данных
	 * @param buffer буфер из которого происходит считывание, предупреждения аналогичные
	 * @param BUF_SZ размер буфера - эквивалентно размеру записываемой информации
	 */
	void write(size_t address, const char* buffer, size_t BUF_SZ);

	// working with blocks
	/**
	 * @brief получение свободного блока из файловой системы для нужд записи, в файловой системе блок помечается как занятый
	 * 
	 * @return size_t адрес этого блока
	 */
	size_t getBlock(); // get free block from fs
	/**
	 * @brief освобождение блока, блок больше не используется записью, в файловой системе помечается как свободный
	 * 
	 * @param address адрес освобождаемого блока
	 */
	void putBlock(size_t address); // put block to free map
	/**
	 * @brief запись дескриптора на диск
	 * 
	 */
	void writeInode();

public:
	/**
	 * @brief создает объект запись по переданному дескриптору и записывает его в переданную файловую систему
	 * 
	 * @param inode дескриптор, по которому создается запись
	 * @param fs файловая система, которой принадлежит данная запись
	 */
	Entry(const INode& inode, FileSystem& fs);
	/**
	 * @brief создает объект запись по адресу дескриптора в файловой системе, которая передана
	 * 
	 * @param inodeAddress адрес дескриптора, по которому создается запись
	 * @param fs файловая система, в которой находится данная запись
	 */
	Entry(size_t inodeAddress, FileSystem& fs);
	/**
	 * @brief деструктор который ничего не делает
	 	он просто виртуальный
		 чтобы наследники удалялись
	 * 
	 */
	virtual ~Entry() {};

	/**
	 * @brief получение адреса родительской директории, в которой находится запись
	 	может быть 0, если вызывается для корневой директории
	 * 
	 * @return size_t адрес корневой директории
	 */
	size_t getParent() { return inode.parentAddress; }

	/**
	 * @brief печатает имя записи в консоль
	 	ну еще записывает это имя в переданную строку
	 * 
	 * @param out строка, в которую записывается имя файла
	 */
	void name(std::string& out) {
		std::cout << inode.name << (inode.mode[0] ? "/" : "");
		out += inode.name + (inode.mode[0] ? "/" : "");
	}
	/**
	 * @brief тип записи - является ли запись файлом или может директорией
	 * 
	 * @return true если директория
	 * @return false если файл
	 */
	bool type() { // true if dir
		return inode.mode[0];
	}
	/**
	 * @brief полное удаление записи с диска
	 	все блоки которые ранее принадлежали записи, включая головной,  теперь являются свободными
	 * 
	 */
	void remove();
};

/**
 * @brief класс который является наследником записи
	предназначен для хранения на диске текстовой информации(в качестве контента записи)
 * 
 */

class File : public Entry
{
private:
	/**
	 * @brief текущая позиция каретки в файле
	 * 
	 */
	size_t position = 0;
public:
	using Entry::Entry;

	/**
	 * @brief чтение информации из файла
	 	информация считывается начиная с текущей позиции в файле
		 в консоль
	 * 
	 * @param size размер информации, который необходимо считать
	 	по умолчанию -1 - в данном случае считывается файл целиком
		 в случае размера, при котором происходит выход за границу файла, считывание не происходит
		 после считывания каретка переводится на позицию на которой произошел конец считывания
	 */
	void fread(size_t size = -1);
	/**
	 * @brief дозапись информации в файл
	 	информация записывается в конец файла
	 * 
	 * @param buffer буфер из которого считывается информация, в случае невалидного буфера например nullptr произойдет обращение к недопступному адресу, что вызовет ошибку сегментации
	 * @param size размер информации которую нужно дозаписать, при слишком большом размере запись не произойдет
	 */
	void fwrite(const char* buffer, size_t size);
	/**
	 * @brief переставляет каретку на новую позиция
	 * 
	 * @param newPosition новая позиция
	 	если позиция не принадлежит файлу, переустановка каретки не произойдет
	 */
	void fseek(size_t newPosition);
	/**
	 * @brief закрывание файла
	 	необходимо выполнить перед вызовом деструктора для того чтобы файл сохранился корректно
	 * 
	 */
	void fclose();
};

/**
 * @brief класс директория, которая хранит указатели на файлы в качестве контента записи
 * 
 */

class Directory : public Entry
{
private:
	/**
	 * @brief флаг сигнализирующий о том, открыта или директория или нет
	 * 
	 */
	bool opened = false;
	/**
	 * @brief таблица из имен записей, содержащихся в данной директории, и их адресов в файловой системе, к которой принадлежит данная директория 
	 * 
	 */
	Map<std::string, size_t> table;
public:
	using Entry::Entry;

	/**
	 * @brief открытие директории в ходе которого происходит заполнение таблицы файлов
	 	необходимо выполнить для возможности работы с директорией
	 * 
	 */
	void open(); // from disk
	/**
	 * @brief закрытие директории, необходимо вызвать перед вызовом деструктора для корректного сохранения директории
	 * 
	 */
	void close(); // to disk // false if file is too big

	/**
	 * @brief выводит список записей находящихся в данной директории
	 * 
	 * @param out строка, в которую происходит запись вывода листа
	 */
	void list(std::string& out);
	/**
	 * @brief получение адреса файла в файловой системе по его имени
	 * 
	 * @param fileName имя файла, адрес которого хотим получить
	 * @return size_t адрес этого файла, вернется 0 в случае если запись с таким именем не принадлежит директории
	 */
	size_t getFileAddress(const std::string& fileName); // 0 if it isnt exist
	/**
	 * @brief добавление записи в таблицу файлов
	 	теперь в данной директории содержится еще файл с указанным адресом
	 * 
	 * @param fileAddress адрес файла, который необходимо добавить в директорию
	 */
	void addFile(size_t fileAddress);
	/**
	 * @brief удаление записи из таблицы файлов
	 	при этом файл не удаляется с диска, удаляется запись с этим файлом из таблицы
	 * 
	 * @param fileAddress 
	 */
	void rmvFile(size_t fileAddress);

	/**
	 * @brief возвращает итератор который указывает на начало таблицы файлов
	 * 
	 * @return итератор указывающий на начало
	 */
	ConstIterator<std::string, size_t> begin();
	/**
	 * @brief возвращает итератор который указывает на конец таблицы файлов
	 * 
	 * @return итератор указывающий на конец
	 */
	ConstIterator<std::string, size_t> end();
};

/**
 * @brief класс являющийся вариацией файла, необходимый для текстового редактора
 * 
 */

class Editor : public Entry
{
	/**
	 * @brief текст содержащийся в данном файле
	 * 
	 */
	std::string Mytext;
public:
	using Entry::Entry;

	/**
	 * @brief окрытие файла, необходимо для того чтобы считать текст 
	 * 
	 */
	void open();
	/**
	 * @brief вставка информации в файл
	 * 
	 * @param pos позиция в которую надо вставить информацию, при слишком большой позиции вставки не произойдет
	 * @param data информация которую необходимо вставить
	 */
	void insert(size_t pos, const std::string& data);
	/**
	 * @brief тоже самое но вместо троки вставляется один символ
	 * 
	 * @param pos --||--
	 * @param token --||--
	 */
	void insert(size_t pos, char token);
	/**
	 * @brief удаление информации из файла
	 * 
	 * @param pos позиция которая указывает на начало удаляемой информации
	 * @param size размер удаляемой информации, при слишком большом размере удаление не произойдет
	 */
	void remove(size_t pos, size_t size);
	/**
	 * @brief возвращает текст содержащийся в файле
	 * 
	 * @return текст
	 */
	const std::string& show();
	/**
	 * @brief сохранение файла, необходимо выполнить для сохранения измениний выполненных с файлом
	 * 
	 */
	void save();
	/**
	 * @brief закрытие файла, необходимо выполнить для корректного сохранения файла 
	 * 
	 */
	void close();
	void oldinsert(size_t pos, const char* buffer, size_t size);
	void oldremove(size_t pos, size_t size);
	void oldshow(size_t begin = -1, size_t end = -1);
};
